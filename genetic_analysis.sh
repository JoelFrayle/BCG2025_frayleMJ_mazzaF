cat << 'EOF' > run_pipeline.py
import os
import subprocess

# Set up base directories and file paths
base_dir = "genomics2025_exam"  # Main folder for results
data_dir = "/home/BCG2025_genomics_exam"  # Folder where raw input files are stored
reference_index = os.path.join(data_dir, "uni")  # Bowtie2 reference index
reference_fasta = os.path.join(data_dir, "universe.fasta")  # Reference genome FASTA
target_bed = os.path.join(data_dir, "exons16Padded_sorted.bed")  # Target regions in BED format

# Define case groups by inheritance mode
# Frayle cases: 593, 671, 731, 732, 739
# Mazza cases: 628, 641, 689, 697 738
cases = {
    "AD": ["case731", "case593", "case671", "case738", "case689"],
    "AR": ["case732", "case739", "case697", "case641", "case628"]
}

# Function to run a shell command (optionally in the background)
def run_command(cmd, cwd=None, background=False):
    print(f"Running: {cmd}")
    if background:
        process = subprocess.Popen(cmd, shell=True, cwd=cwd,
                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print(f"Process started with PID: {process.pid}")
        return process
    else:
        subprocess.run(cmd, shell=True, check=True, cwd=cwd)

# Get a VCF filter string for bcftools based on the mode
def get_vcf_filter(mode):
    if mode == "AD":
    # For Autosomical dominant the child suffers a mutation, so non of the parents have the alele, but the child does. The order in our aligment is mom, dad and child
    # so GT[0] = mother, GT[1] = father and GT[2] = child
        return 'GT[2]="0/1" && GT[0]="0/0" && GT[1]="0/0" && QUAL>=20'
    elif mode == "AR":
    # For autosomical recesive both of parents are heterozygotes and the child homozygote 
        return 'GT[2]="1/1" && GT[0]="0/1" && GT[1]="0/1" && QUAL>=20'
    return None

# Create main folders if they don't exist
os.makedirs(base_dir, exist_ok=True)
fastqc_results_dir = os.path.join(base_dir, "fastqc_results")
os.makedirs(fastqc_results_dir, exist_ok=True)
multiqc_report_dir = os.path.join(base_dir, "multiqc_report")  # To be generated by MultiQC
cases_dir = os.path.join(base_dir, "cases")
os.makedirs(cases_dir, exist_ok=True)

# Global analysis: prepare FastQC symlinks and run FastQC/MultiQC
print("Starting global FastQC analysis...")
all_fq_links = []
for mode, case_list in cases.items():
    for case in case_list:
        for role in ["child", "father", "mother"]:
            fq_file = f"{case}_{role}.fq.gz"
            fq_path = os.path.join(data_dir, fq_file)
            link_path = os.path.join(fastqc_results_dir, fq_file)
            if not os.path.exists(link_path):
                os.symlink(fq_path, link_path)
            # Make the link path relative to base_dir so FastQC finds it correctly
            rel_link = os.path.relpath(link_path, base_dir)
            all_fq_links.append(rel_link)

# Run FastQC and then MultiQC, using base_dir as the current working directory
run_command(f"fastqc {' '.join(all_fq_links)} -o fastqc_results", cwd=base_dir)
run_command(f"multiqc fastqc_results -o multiqc_report", cwd=base_dir)

# Process each case, grouping them by inheritance mode
for mode, case_list in cases.items():
    mode_dir = os.path.join(cases_dir, mode)
    os.makedirs(mode_dir, exist_ok=True)
    
    for case in case_list:
        case_path = os.path.join(mode_dir, case)
        os.makedirs(case_path, exist_ok=True)
        print(f"Processing {case} in {mode}...")
        
        # Create local symlinks for the FASTQ files in this case folder
        for role in ["child", "father", "mother"]:
            fq_file = f"{case}_{role}.fq.gz"
            fq_path = os.path.join(data_dir, fq_file)
            link_path = os.path.join(case_path, fq_file)
            if not os.path.exists(link_path):
                os.symlink(fq_path, link_path)

        # Run Bowtie2 alignment for each role (child, father, mother) in parallel
        processes = []
        for role, rgid in zip(["child", "father", "mother"], ["SC", "SF", "SM"]):
            fq = f"{case}_{role}.fq.gz"
            bam = f"{case}_{role}.bam"
            log_file = f"bowtie2_{case}_{role}.log"
            cmd = (
                f"bowtie2 -U {fq} -x {reference_index} --rg-id '{rgid}' --rg 'SM:{role.capitalize()}' "
                f"| samtools view -Sb | samtools sort -o {bam} > {log_file} 2>&1"
            )
            process = run_command(cmd, cwd=case_path, background=True)
            processes.append(process)
            
        # Wait for all alignment processes to finish
        for process in processes:
            process.wait()

        # Index the BAM files using samtools
        for role in ["child", "father", "mother"]:
            bam = f"{case}_{role}.bam"
            run_command(f"samtools index {bam}", cwd=case_path)

        # Run variant calling with Freebayes
        trio_bams = " ".join([f"{case}_{role}.bam" for role in ["child", "father", "mother"]])
        vcf_output = f"Trio{case[-3:]}.vcf"
        cmd = (
            f"freebayes -f {reference_fasta} -t {target_bed} -m 20 -C 5 -Q 10 --min-coverage 10 {trio_bams} > {vcf_output}"
        )
        run_command(cmd, cwd=case_path)
        
        # Filter the VCF file with bcftools using the appropriate filter for the mode
        vcf_filter = get_vcf_filter(mode)
        if vcf_filter:
            run_command(
                f"bcftools view -i '{vcf_filter}' {vcf_output} > candidates{case[-3:]}.vcf",
                cwd=case_path
            )
            
        print(f"Finished processing {case}.")

print("Pipeline completed! Check the multiqc_report and case-specific folders.")
EOF
# Then we run the pipeline in the background
nohup python3 run_pipeline.py &
